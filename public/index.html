<!DOCTYPE html>

<html>
  <head>
    <title>Disco</title>
    <style type="text/css">
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    body {
      background-color: #191919;
    }

    .node {
      stroke: #444444;
      stroke-width: 3px;
    }

    .link {
      stroke: #444444;
      stroke-width: 3px;
    }

    .label,
    .labelHighlight {
      font-family: Helvetica;
      font-size: 12px;
      font-weight: bold;
      fill: #999999;
      pointer-events: none;
    }

    .labelHighlight {
      display: none;
    }

    .node.focused,
    .link.focused {
      stroke: #dddddd;
      stroke-width: 5px;
    }

    .label.focused,
    .labelHighlight.focused {
      fill: #eeeeee;
      fill-opacity: 1.0;
      font-size: 14px;
    }

    .labelHighlight.focused {
      fill: #444444;
      display: block;
      filter: url(#blur);
    }
    </style>
    <script src="app/lib/d3.v2.min.js"></script>
  </head>
  <body>
    <script>
    var utils = {}

    utils.uniq = function (list) {
      var uniqueList = []
      var lastItem = null
      list.sort().forEach(function (item) {
        if (item != lastItem) {
          uniqueList.push(item)
        }
      })
      return uniqueList
    }

    utils.pluck = function (property) {
      var components = property.split(".")
      return function (obj) {
        var o = obj
        for (var i = 0; i < components.length; i++) {
          o = o[components[i]]
        }
        return o
      }
    }

    var colors = function () {
      var alternatives = ["#ff8964", "#6f2b15", "#bc5837", "#0a6f58", "#37bc9e", "#6e431a", "#bb6d23", "#09596e", "#49d8ff", "#bb7123", "#6e451a", "#7b2ebb", "#cb8cff"]
      alternatives = alternatives.sort(function (a, b) { return Math.round(Math.random() - 0.5)})
      return function (i) {
        return alternatives[i % alternatives.length]
      }
    }()

    var createTopologyManager = function (topology) {
      var self = {}
      var apps = utils.uniq(topology.hosts.map(utils.pluck("app")))
      var nodes = []
      var links = []

      self.nodes = function () { return nodes }
      self.links = function () { return links }
      self.apps = function () { return apps }

      self.randomHost = function () {
        return topology.hosts[Math.floor(Math.random() * topology.hosts.length)]
      }

      self.areConnected = function (id1, id2) {
        for (var i = 0; i < topology.connections.length; i++) {
          var c = topology.connections[i]
          if ((c.source == id1 && c.target == id2) || (c.source == id2 && c.target == id1)) {
            return true
          }
        }
        return false
      }

      var findHost = function (id) {
        for (var i = 0; i < topology.hosts.length; i++) {
          if (topology.hosts[i].id == id) {
            return topology.hosts[i]
          }
        }
        return null
      }

      var findNodeIndex = function (id) {
        for (var i = 0; i < nodes.length; i++) {
          if (nodes[i].id == id) {
            return i
          }
        }
        return -1
      }

      var eachConnection = function (block) {
        topology.connections.forEach(block)
      }

      self.addNode = function (node, connectionsListener) {
        eachConnection(function (connection) {
          var link = {target: -1, source: -1}
          if (connection.target == node.id) {
            link.target = nodes.length
            link.source = findNodeIndex(connection.source)
          } else if (connection.source == node.id) {
            link.target = findNodeIndex(connection.target)
            link.source = nodes.length
          }
          if (link.source != -1 && link.target != -1) {
            links.push(link)
          } else if (link.source != -1) {
            var host = findHost(connection.target)
            if (host != null && connectionsListener != null) {
              connectionsListener(host)
            }
          } else if (link.target != -1) {
            var host = findHost(connection.source)
            if (host != null && connectionsListener != null) {
              connectionsListener(host)
            }
          }
        })
        nodes.push(node)
      }

      return self
    }

    var createTopologyBuilder = function (topologyManager) {
      var self = {}
      var candidates = [topologyManager.randomHost()]

      var isCandidate = function (id) {
        for (var i = 0; i < candidates.length; i++) {
          if (candidates[i].id == id) {
            return true
          }
        }
        return false
      }

      self.addNext = function () {
        if (candidates.length == 0) {
          return false
        }

        var host = candidates.shift()
        var node = {id: host.id, name: host.name, app: host.app}
        topologyManager.addNode(node, function (connectedHost) {
          if (!isCandidate(connectedHost.id)) {
            candidates.push(connectedHost)
          }
        })

        return true
      }

      return self
    }

    var createVisualizationController = function (d3, win, topologyManager) {
      var self = {}
      var svg = null
      var linksGroup = null
      var nodesGroup = null
      var labelsGroup = null
      var labelHighlightsGroup = null
      var forceLayout = null

      win.onresize = resizeUpdate

      var width = function () {
        return win.innerWidth
      }

      var height = function () {
        return win.innerHeight
      }

      self.start = function () {
        svg = d3.select("body").append("svg:svg")
          .attr("width", width())
          .attr("height", height())

        linksGroup = svg.append("svg:g").attr("class", "links")
        nodesGroup = svg.append("svg:g").attr("class", "nodes")
        labelHighlightsGroup = svg.append("svg:g").attr("class", "labelHighlights")
        labelsGroup = svg.append("svg:g").attr("class", "labels")

        forceLayout = d3.layout.force()
          .nodes(topologyManager.nodes())
          .links(topologyManager.links())
          .linkDistance(100)
          .charge(-400)
          .size([width(), height()])
          .on("tick", layoutUpdate)

        addBlurFilter(svg.append("svg:defs"))

        self.update()
      }

      var addBlurFilter = function (defs) {
        // magic from http://bl.ocks.org/1502762
        var filter = defs.append("svg:filter")
          .attr("id", "blur")
          .attr("filterUnits", "userSpaceOnUse")
          .attr("width", "150%")
          .attr("height", "150%");
        filter.append("svg:feGaussianBlur")
          .attr("in", "SourceGraphic")
          .attr("stdDeviation", 4)
          .attr("result", "blur-out")
        filter.append("svg:feOffset")
          .attr("in", "blur-out")
          .attr("dx", 0)
          .attr("dy", 0)
          .attr("result", "offset-out")
        filter.append("svg:feBlend")
          .attr("in", "SourceGraphic")
          .attr("in2", "offset-out")
          .attr("mode", "normal")
      }

      var resizeUpdate = function () {
        svg.attr("width", width()).attr("height", height())
        forceLayout.size([width(), height()])
        self.update()
      }

      var layoutUpdate = function () {
        linksGroup.selectAll(".link")
          .attr("x1", utils.pluck("source.x"))
          .attr("y1", utils.pluck("source.y"))
          .attr("x2", utils.pluck("target.x"))
          .attr("y2", utils.pluck("target.y"))

        nodesGroup.selectAll(".node")
          .attr("cx", utils.pluck("x"))
          .attr("cy", utils.pluck("y"))

        labelsGroup.selectAll(".label")
          .attr("x", utils.pluck("x"))
          .attr("y", utils.pluck("y"))

        labelHighlightsGroup.selectAll(".labelHighlight")
          .attr("x", utils.pluck("x"))
          .attr("y", utils.pluck("y"))
      }

      var nodeMouseOver = function (d) {
        var nodeFocus = function (dd) {
          return dd.id == d.id || topologyManager.areConnected(dd.id, d.id)
        }
        var labelFocus = function (dd) {}
        nodesGroup.selectAll(".node").classed("focused", nodeFocus)
        labelsGroup.selectAll(".label").classed("focused", nodeFocus)
        labelHighlightsGroup.selectAll(".labelHighlight").classed("focused", nodeFocus)
        linksGroup.selectAll(".link").classed("focused", function (dd) {
          return dd.source.id == d.id || dd.target.id == d.id
        })
      }

      var nodeMouseOut = function (d) {
        nodesGroup.selectAll(".node").classed("focused", false)
        linksGroup.selectAll(".link").classed("focused", false)
        labelsGroup.selectAll(".label").classed("focused", false)
        labelHighlightsGroup.selectAll(".labelHighlight").classed("focused", false)
      }

      self.update = function () {
        linksGroup.selectAll("line.link")
          .data(topologyManager.links(), function (d) { return [d.source.id, d.target.id].join("-") })
          .enter()
          .insert("svg:line", "circle.node")
            .attr("class", "link")

        nodesGroup.selectAll("circle.node")
          .data(topologyManager.nodes(), utils.pluck("id"))
          .enter()
          .insert("svg:circle")
            .attr("class", "node")
            .attr("r", 10)
            .attr("fill", function (d) { return colors(topologyManager.apps().indexOf(d.app)) })
            .on("mouseover", nodeMouseOver)
            .on("mouseout", nodeMouseOut)
            .call(forceLayout.drag)

        labelsGroup.selectAll("text.label")
          .data(topologyManager.nodes(), utils.pluck("id"))
          .enter()
          .insert("svg:text")
            .attr("class", "label")
            .attr("dx", 15)
            .attr("dy", 4)
            .attr("fill-opacity", 1.0)
            .text(utils.pluck("name"))
          .transition()
            .duration(3000)
            .attr("fill-opacity", 0.0)

        labelHighlightsGroup.selectAll("text.labelHighlight")
          .data(topologyManager.nodes(), utils.pluck("id"))
          .enter()
          .insert("svg:text")
            .attr("class", "labelHighlight")
            .attr("dx", 15)
            .attr("dy", 4)
            .text(utils.pluck("name"))

        forceLayout.size([width(), height()])
        forceLayout.start()
      }

      return self
    }

    d3.json("data/staging.json", function (topology) {
      var topologyManager = createTopologyManager(topology)
      var topologyBuilder = createTopologyBuilder(topologyManager)
      var visualizationController = createVisualizationController(d3, window, topologyManager)

      visualizationController.start()

      var intervalId = setInterval(function () {
        if (topologyBuilder.addNext()) {
          visualizationController.update()
        } else {
          clearInterval(intervalId)
        }
      }, 100)
    })
    </script>
  </body>
</html>